# 第3章 Java的基本程序设计结构
##3.1 一个简单的Java应用程序
	1. 在类的源文件中必须包含一个main()方法。
	2. 根据Java语言规范，main()方法必须声明为public。在Java SE1.4及以后的版本中强制main()方法是public的。
	3. Java中的main()方法必须是静态的。关键字void表示这个方法没有返回值,所不同的是main()方法没有为操作系统返回"退出代码"。如果main()方法正常退出，那么Java应用程序的退出代码为0，表示成功地运行了程序。如果希望在终止程序时返回其他的代码，那就需要调用System.ext()方法。
## 3.2 注释
	1. Java中的注释也不会出现在现在可执行程序中。因此，可以在源程序中根据需要添加任意多的注释，而不必担心可执行代码会膨胀。
	2. 在Java中，有3种标记注释的方式。
		1. 最常用的方式是使用//
		2. 需要长篇的注释时，既可以在每行的注释前面标记//,也可以使用/*和*/将一段比较长的注释括起来。
		3. 以/**开始，以*/结束，这种注释可以用来自动地生成文档。
## 3.3 数据类型
	1. Java是一种强类型语言。这就意味着必须为每一个变量声明一种类型。在Java中，一共有8种基本 类型，其中4种整形、2种浮点类型、1种用于表示Unicode编码的字符单元的字符类型和1种用于表示真值的boolean类型。
### 3.3.1 整型
	1. 整形用于表示没有小数部分的数值，它允许是负数。Java提供了4种整型。
		1. int 4字节
		2. short 2字节
		3. long 8字节
		4. byte 1字节
	2. 在Java中，整型的范围与运行Java代码的机器无关。
	3. Java没有任何无符号(unsigned)形式的int、long、short或byte类型
### 3.3.2 浮点类型
	1. 浮点类型用于表示有小数部分的数值。在Java中有两种浮点类型。
		1. float 4字节
		2. double 8字节
	2. double表示这种类型的数值精度是float类型的两倍(有人称之为双精度数值)。绝大部分应用程序都采用double类型。
	3. 只有很少的情况适合使用float类型，例如，需要单精度数据的库，或者需要存储大量数据。
	4. 可以使用十六进制表示浮点数值。例如0.125可以表示成0x1.0p-3。在十六进制表示法中,使用p表示指数，而不是e。注意，**尾数采用十六进制，指数采用十进制**。指数的基数是2，而不是10.
	5. 所有的浮点数值计算都遵循IEEE 754规范。具体来说，下面是用于表示溢出和出错情况的三个特殊的浮点数值：
		1. 正无穷大(Double/Float.POSITIVE_INFINITY)
		2. 负无穷大(Double/Float.NEGATIVE_INFINITY)
		3. NaN(不是一个数字)(Double/Float.Nan)
		4. 特别说明
			1. 不用这样检测一个特定值是否等于Double.NaN:if(x == Double.NaN)
			2. 所有"非数值"的值都认为是不相同的。然而，可是使用Double.NaN()方法:if(Double.NaN(x))
		5. 警告
			1. 浮点数值不适用于无法接受舍入误差的金融计算中。因为二进制系统无法精确的表示分数1/10。**如果在数值计算中不允许有任何舍入误差，就应该使用BigDecimal类**
### 3.3.3 char类型
	1. char类型原本用于表示单个字符。不过，现在情况已经有所改变。如今，有些Unicode字符可以用一个char值描述，另外一些Unicode字符则需要两个char值。稍后会解释。
	2. char类型的字面量值要用单引号括起来。
	3. char类型的值可以表示为十六进制值，其范围从\u0000到\Uffff。
	4. 除了转义序列\u之外，还有一些用于表示特殊字符的转义序列，所有这些转义序列都可以出现在**加引号的字符字面量或字符串中**。例如,'\u2122'或"Hello\n"。转义序列\u还可以出现在加引号的字符常量和字符串之外(**而其它所有转义序列不可以**)。
		1. 警告:Unicode转义序列会在解析代码之前得到处理。
		2. 更隐秘地，一定要当心注释中地\u。
			1. 注释// \u00A0 is a newline:会产生一个语法错误，因为读程序时\u00A0会替换成一个换行符
			2. // Look inside c:\users : 也会产生一个语法错误，因为\u后面并未跟着4个十六进制数。
### 3.3.4 Unicode和char
	1. 强烈建议不要再程序中使用char类型，除非确实需要处理UTF-16代码单元。最好将字符串作为抽象数据类型处理。
### 3.3.5 boolean类型
	1. boolean(布尔)类型有两个值:false和true，用来判断逻辑条件。整型值和布尔值之间不能进行互换。
## 3.4 变量
	1. 变量名必须是一个以字母开头并由字母和数字构成的序列。变量名中所有的字符都是有意义的，并且大小写敏感。变量名的长度基本上没有限制。
	2. 提示
		1. 如果想要知道那些Unicode字符属于Java中的"字母"，可以使用Character类的isJavaIdentifierStart和isJavaIdentifierPart方法来检查
		2. 尽管$是一个合法的java字符，但不要在你自己的代码中使用这个字符。他只用在java编译器或其他工具生成的名字中。
### 3.4.1 变量初始化
	1. 声明一个变量之后，必须用赋值语句对变量进行显式初始化，千万不要使用未初始化的变量。
### 3.4.2 常量
	1. 在Java中，利用关键字final指示常量。关键字final表示这个变量只能被赋值一次。一旦被赋值后，就不能再更改了。习惯上，常量名使用全大写。
	2. 在Java中，经常希望某个常量可以在一个类中的多个方法中使用，通常将这些常量称为类常量。可以使用关键案子static final设置一个类常量。
## 3.5 运算符
	1. 需要注意，整数被0除将会产生一个异常，而浮点数被0除将会得到无穷大或NaN结果。
	2. 注释
		1. 在默认情况下，虚拟机设计者允许对中间计算结果采用扩展的精度。但是，对于使用**strictfp**关键字标记的方法必须使用严格的浮点计算来生成可再生的结果。strictfp可作用在方法上，表示该方法中的所有指令都将使用严格的浮点计算。也可作用在类上，则表示这个类中的所有方法都要使用严格的浮点计算。
		2. 实际的计算方式将取决于处理器的行为。在默认情况下，中间结果允许使用扩展的指数，但不允许使用扩展的位数。因此，这两种方式的区别仅仅在于采用默认的方式不会产生溢出，而采用严格的计算有可能会产生溢出。
### 3.5.1 数学函数与常量
	1. 注释
		1. 在Math类中，为了达到最快的性能，所有的方法都使用计算机浮点单元中的例程。如果得到一个完全可预测的结果比运行速度更重要的话，那么就应该使用StrictMath类。它使用"fblibm"实现算法，**以确保在所有平台上得到相同的结果**。
### 3.5.2 数值类型之间的转换
	1. 当对两个数值进行二元操作时，先要将两个操作数转换为同一种类型，然后再进行计算
		1. 如果两个操作数中有一个是double类型，另一个操作数就会转换为double类型
		2. 否则，如果其中一个操作数是float类型，另一个操作数将会转换为float类型
		3. 否则，如果其中有一个操作数是long类型，另一个操作数将会转换为long类型
		4. 否则，两个操作数都将会转换为int类型。
	2. 数值类型之间的合法转换，实线代表精度不会丢失，虚线代表可能会丢失精度。![](java核心技术\数值类型之间的合法转化.png)
### 3.5.3 强制类型转换
	1. 警告
		1. 如果试图将一个数值从一种类型强制转换为另一种类型，而又 超出了目标类型的表示范围，结果就会截断为一个完全不同的值。
		2. 不要在boolean类型与任何数值类型之间进行强制类型转换，这样可以防止发生错误。只有极少数的情况下才需要将布尔类型转换为数值类型，这时可以使用条件表达式b?1:0
### 3.5.4 结合赋值和运算符
	1. 注释
		1. 如果运算符得到一个值，其类型与左侧操作数的类型不同，就会以左侧类型为准发生强制类型转换。
### 3.5.5 自增与自减运算符
	1. 自增和自减运算符会改变**变量的值**，所以它们的操作数不能是数值。
### 3.5.6 关系和boolean运算符
### 3.5.7 位运算符
	1. 警告
		1. 移位运算符的右操作数要完成模32的运算(除非左操作数是long类型，在这种情况下需要对右操作数模64).
	2. 最后，>>>运算符会用0填充高位，这与>>不同，它会用符号位填充高位。不存在<<<运算符。
...
## 3.6 字符串
	1. 